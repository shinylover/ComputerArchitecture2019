; Computer Architectures (02LSEOV)
; EXAM 2 SEPTEMBER 2013
;ERIC SERRA s209007
;Electronics Engineering - Embedded Systems @ POLITO
NUM EQU 6
N_EMPLOYEES EQU 30
N_MAX_WORKING_DAYS_PER_MONTH EQU 23
N_MAX_RECORDS_PER_MONTH EQU N_EMPLOYEES * N_MAX_WORKING_DAYS_PER_MONTH
N_MONTHS EQU 12
N_RECORDS EQU N_MAX_RECORDS_PER_MONTH * N_MONTHS
N_BYTES_PER_RECORD EQU 3
N_BYTES_OF_RECORD EQU N_BYTES_PER_RECORD * N_RECORDS

	.MODEL small
    .STACK
    .DATA
  ;EG = MON=1 DAY=27 EMPL=12 CHARGE = 512
  ;0001 11011 01100 1000000000
  ;00011101 1011001 000000000
  ;		29		178   		0
CANTEEN_CHARGES_DATABASE DB N_BYTES_OF_RECORD DUP (0)
CHARGE DW ?		;TEMP DATA
DAY DB ?		;TEMP DATA
EMPL DB ?		;TEMP DATA
MON DB ?		;TEMP DATA
SEARCH_MON DB ?		;REQUESTED DATA
SEARCH_DAY DB ?		;REQUESTED DATA
SEARCH_EMP DB ?		;REQUESTED DATA
TOT DB 3 DUP (0)		;RESULTS 23 BITS NEEDED, SINCE I HAVE TO USE MULTIPLE OF 8, 24BITS IS SMALLEST POSSIBLE.
EMPTOT DB 3 DUP (0)		;RESULTS
MONTOT DB 3 DUP (0)		;RESULTS
EMPMON DW ?				;RESULTS
DAYMON DW ?				;RESULTS
;I/O
ERRORE DB 10,13,'ERROR.',10,13,'$'
OK DB 10,13,'OK.',10,13,'$'
STARTASK DB 10,13,'INSERT ITEM NUM.1-5 OR 0 TO EXIT $'  ;10=LF 13=CR
TASKTWO DB 10,13,'INSERT EMPLOYEE. 01-30 $'  ;10=LF 13=CR
TASKTHREE DB 10,13,'INSERT MONTH 01-12. $'  ;10=LF 13=CR
TASKFIVE DB 10,13,'INSERT DAY 01-31. $'  ;10=LF 13=CR
SEARCH1 DB NUM,NUM+1 DUP(?)
QUOTIENT DW 0
OUT_STRING DB '        $' ;8 SPACES

	.CODE
    .STARTUP
	
XOR SI,SI
DATABASE:
	
		MOV DAY,1
		MOV MON,1
		MOV EMPL,1
		MOV CHARGE,400
		
		MOV CX,12
		MONTHS:
			PUSH CX
			MOV CX,23
			DAYS:
				PUSH CX
				MOV CX,30
				EACHEMPLOYEE:
					LEA AX,CANTEEN_CHARGES_DATABASE[SI]
							PUSH AX
							CALL WRITE_rec 
							POP AX
							ADD SI,3
					INC EMPL		;EVERYBODY
					ADD CHARGE,20 
;EG. EACH SUCCESSIVE EMPLOYEE SPENDS 20 CENTS MORE (1ST SPENDS 4$ , 30TH SPENDS 10$)
				LOOP EACHEMPLOYEE
				MOV CHARGE,400
				MOV EMPL,1
				INC DAY
				POP CX
			LOOP DAYS
			MOV DAY,1
			INC MON
			POP CX
		LOOP MONTHS
;NB: THIS DATABASE IS WELL SORTED AS ASKED IN THE EXAM
	
	
RESTART:
MOV CX,8
XOR SI,SI
REINIT:
MOV OUT_STRING[SI],' ' ;8 SPACES
INC SI
LOOP REINIT
MOV OUT_STRING[SI],'$' ;8 SPACES
XOR SI,SI
XOR CX,CX
XOR BX,BX ;CLEAR THIS REGISTERS FOR PRECAUTION

; PRINT START
MOV DX,OFFSET STARTASK	
MOV AH,09H
INT 21H	
; READ
MOV AH,01H
INT 21H	
CMP AL,'1'
JE ITEM1
CMP AL,'2'
JE ITEM2
CMP AL,'3'
JE ITEM3
CMP AL,'4'
JE ITEM4
CMP AL,'5'
JE ITEM5	
CMP AL,'0'
JE THE_END
MOV DX,OFFSET ERRORE
MOV AH,09H
INT 21H		
JMP RESTART

;======================================= ITEM1 ======================================================	
ITEM1:
	MOV CX,N_RECORDS
	XOR SI,SI
	XOR BX,BX			;USED REGS
	XOR DX,DX			;TO CALCULATE TOTAL 
	TOTALOOP: LEA AX,CANTEEN_CHARGES_DATABASE[SI]
		PUSH BX
		PUSH AX
		CALL read_rec		;FUNCTION THAT RECEIVES ADDR OF A RECORD, GIVES BACK THE VALUES CONTAINEDIN IT , IN GLOBAL VARIABLES.
		POP AX
		POP BX
		CMP MON,0		;IF MON=0 RECORD NON VALID->DATABASE ENDED
		JE END1
		ADD BX,CHARGE		;MY WAY TO IMPLEMENT ADDITION 24BIT + 10BIT -> 24BIT:
							;AT MOST , WHEN ADDING 1000, ONE OVERFLOW OCCURS AND "CF" IS SET
		ADC DL,0			;I USE ADC TO ADD THE (EVENTUALLY SET) CF 
		ADD SI,3
		LOOP TOTALOOP
END1:MOV TOT,BL
	MOV [TOT+1],BH ;AT THE AND SAVES RESULT ON A VARIABLE
	MOV [TOT+2],DL
	
;MAX 8 DIGIT NUMBER PRINT (24 bit)
MOV AX,BX
XOR DH,DH
;DL IS ALREADY IN PLACE	
 MOV CX,1000       
MOV DI,7 ;MAX 8 CHARS   
    CONV2ASCII:
	DIV CX	       ;DIV DX:AX/1000
	MOV QUOTIENT,AX		;0<Q<16.000
	MOV AX,DX			;0<R<999
	CONV_R:
	XOR DX,DX
	MOV CX,10 ;AX/CX -> Q=AX R=DX
	DIV CX
	ADD DX,48	       ;ADD 48 TO REMAINDER TO GET ASCII CHARACTER OF NUMBER
	MOV OUT_STRING[DI],DL
	DEC DI
	CMP DI,4		;WRITES AT LEAST THESE 3 NUMBERS SO IF NUMBER IS LESS THAN 100 WILL WRITE 054 , 003 FOR EXAMPLE
	JNE CONV_R
	MOV AX,QUOTIENT
	CONV_Q:
	XOR DX,DX
	DIV CX
	ADD DX,48	       ;ADD 48 TO REMAINDER TO GET ASCII CHARACTER OF NUMBER
	MOV OUT_STRING[DI],DL
	DEC DI
	CMP AX,0
	JZ EXTT	       ;IF AX=0, END OF THE PROCEDURE (DON'T WRITE OTHER USELESS ZEROS
	JMP CONV_Q	       ;ELSE REPEAT
    EXTT:
MOV AH,2
MOV DL,10
INT 21H
MOV DX,OFFSET OUT_STRING	
 MOV AH,09H
INT 21H

	JMP RESTART

;======================================= ITEM2 ======================================================	
ITEM2:
	MOV DX,OFFSET TASKTWO	  ; PRINT QUESTION
	MOV AH,09H
	INT 21H	
	
	LEA DX,SEARCH1		;RECEIVE ANSWER
	MOV AH,0AH
	INT 21H
	MOV AL,SEARCH1[2]		;CONV. TO NUMBER
	SUB AL,'0'
	MOV CL,10
	MUL CL  
	MOV CL,SEARCH1[3]
	SUB CL,'0'
	ADD AL,CL
	MOV SEARCH_EMP,AL
	
	MOV CX,N_RECORDS
	XOR SI,SI
	XOR BX,BX
	XOR DX,DX
	EMPLOOP: LEA AX,CANTEEN_CHARGES_DATABASE[SI]
		PUSH BX
		PUSH AX
		CALL read_rec
		POP AX
		POP BX
		CMP MON,0		;IF MON=0 RECORD NON VALID->DATABASE ENDED
		JE END2
		MOV AL,SEARCH_EMP
		CMP EMPL,AL				;IF THE EMPLOYEE IS THE RIGHT ONE, ADD THE AMOUNT TO HIS TOTAL CHARGE
		JNE NEXT_EMP
		ADD BX,CHARGE
		ADC DL,0
		NEXT_EMP:
		ADD SI,3
		LOOP EMPLOOP
END2:MOV EMPTOT,BL
	MOV EMPTOT+1,BH
	MOV [EMPTOT+2],DL
	
;MAX 8 DIGIT NUMBER PRINT (24 bit)
MOV AX,BX
XOR DH,DH
;DL IS ALREADY IN PLACE	
 MOV CX,1000       
MOV DI,7 ;MAX 8 CHARS   
    CONV2ASCII2:
	DIV CX	       ;DIV DX:AX/1000
	MOV QUOTIENT,AX		;0<Q<16.000
	MOV AX,DX			;0<R<999
	CONV_R2:
	XOR DX,DX
	MOV CX,10 ;AX/CX -> Q=AX R=DX
	DIV CX
	ADD DX,48	       ;ADD 48 TO REMAINDER TO GET ASCII CHARACTER OF NUMBER
	MOV OUT_STRING[DI],DL
	DEC DI
	CMP DI,4		;WRITES AT LEAST THESE 3 NUMBERS SO IF NUMBER IS LESS THAN 100 WILL WRITE 054 , 003 FOR EXAMPLE
	JNE CONV_R2
	MOV AX,QUOTIENT
	CONV_Q2:
	XOR DX,DX
	DIV CX
	ADD DX,48	       ;ADD 48 TO REMAINDER TO GET ASCII CHARACTER OF NUMBER
	MOV OUT_STRING[DI],DL
	DEC DI
	CMP AX,0
	JZ EXTT2	       ;IF AX=0, END OF THE PROCEDURE (DON'T WRITE OTHER USELESS ZEROS
	JMP CONV_Q2	       ;ELSE REPEAT
    EXTT2:
MOV AH,2
MOV DL,10
INT 21H
MOV DX,OFFSET OUT_STRING	
 MOV AH,09H
INT 21H

	JMP RESTART
	
;======================================= ITEM3 ======================================================	
ITEM3:
MOV DX,OFFSET TASKTHREE
MOV AH,09H
INT 21H	

LEA DX,SEARCH1		;RECEIVE ANSWER
	MOV AH,0AH
	INT 21H
	MOV AL,SEARCH1[2]		;CONV. TO NUMBER
	SUB AL,'0'
	MOV CL,10
	MUL CL  
	MOV CL,SEARCH1[3]
	SUB CL,'0'
	ADD AL,CL
	MOV SEARCH_MON,AL

	MOV CX,N_RECORDS
	XOR SI,SI
	XOR BX,BX
	XOR DX,DX
	MONLOOP: LEA AX,CANTEEN_CHARGES_DATABASE[SI]
		PUSH BX
		PUSH AX
		CALL read_rec
		POP AX
		POP BX
		CMP MON,0		;IF MON=0 RECORD NON VALID->DATABASE ENDED
		JE END3
		MOV AL,SEARCH_MON
		CMP MON,AL		;IF THE MONTH IS THE RIGHT ONE, ADD THE AMOUNT TO HIS TOTAL CHARGE
		JNE NEXT_MON
		ADD BX,CHARGE
		ADC DL,0
		NEXT_MON:
		ADD SI,3
		LOOP MONLOOP
END3:MOV MONTOT,BL
	MOV MONTOT+1,BH
	MOV [MONTOT+2],DL

;MAX 8 DIGIT NUMBER PRINT (24 bit)
MOV AX,BX
XOR DH,DH
;DL IS ALREADY IN PLACE	
 MOV CX,1000       
MOV DI,7 ;MAX 8 CHARS   
    CONV2ASCII3:
	DIV CX	       ;DIV DX:AX/1000
	MOV QUOTIENT,AX		;0<Q<16.000
	MOV AX,DX			;0<R<999
	CONV_R3:
	XOR DX,DX
	MOV CX,10 ;AX/CX -> Q=AX R=DX
	DIV CX
	ADD DX,48	       ;ADD 48 TO REMAINDER TO GET ASCII CHARACTER OF NUMBER
	MOV OUT_STRING[DI],DL
	DEC DI
	CMP DI,4		;WRITES AT LEAST THESE 3 NUMBERS SO IF NUMBER IS LESS THAN 100 WILL WRITE 054 , 003 FOR EXAMPLE
	JNE CONV_R3
	MOV AX,QUOTIENT
	CONV_Q3:
	XOR DX,DX
	DIV CX
	ADD DX,48	       ;ADD 48 TO REMAINDER TO GET ASCII CHARACTER OF NUMBER
	MOV OUT_STRING[DI],DL
	DEC DI
	CMP AX,0
	JZ EXTT3	       ;IF AX=0, END OF THE PROCEDURE (DON'T WRITE OTHER USELESS ZEROS
	JMP CONV_Q3	       ;ELSE REPEAT
    EXTT3:
MOV AH,2
MOV DL,10
INT 21H
MOV DX,OFFSET OUT_STRING	
 MOV AH,09H
INT 21H

	JMP RESTART
;===================================== ITEM4 ================================================	
ITEM4:
MOV DX,OFFSET TASKTWO	
MOV AH,09H
INT 21H	
	LEA DX,SEARCH1		;RECEIVE empl
	MOV AH,0AH
	INT 21H
	MOV AL,SEARCH1[2]		;CONV. TO NUMBER
	SUB AL,'0'
	MOV CL,10
	MUL CL  
	MOV CL,SEARCH1[3]
	SUB CL,'0'
	ADD AL,CL
	MOV SEARCH_EMP,AL
	
MOV DX,OFFSET TASKTHREE
MOV AH,09H
INT 21H	
	LEA DX,SEARCH1		;RECEIVE mon
	MOV AH,0AH
	INT 21H
	MOV AL,SEARCH1[2]		;CONV. TO NUMBER
	SUB AL,'0'
	MOV CL,10
	MUL CL  
	MOV CL,SEARCH1[3]
	SUB CL,'0'
	ADD AL,CL
	MOV SEARCH_MON,AL
	

	MOV CX,N_RECORDS
	XOR SI,SI
	XOR DX,DX
	EMPMONLOOP: LEA AX,CANTEEN_CHARGES_DATABASE[SI]
		PUSH AX
		CALL read_rec
		POP AX
		CMP MON,0		;IF MON=0 RECORD NON VALID->DATABASE ENDED
		JE END4
		MOV AL,SEARCH_EMP
		MOV AH,SEARCH_MON
		MOV BL,EMPL				;GOOD WAY TO TEST 2 THINGS TOGETHER , WITH ONE COMPARE
		MOV BH,MON
		CMP AX,BX			;IF BOTH MONTH AND EMPLOYEE ARE CORRECT, ADD THE CURRENT CHARGE TO THE TOTAL
		JNE NEXT_REC
		ADD DX,CHARGE
		NEXT_REC:
		ADD SI,3
		LOOP EMPMONLOOP
END4:MOV EMPMON,DX

;PRINT ROUTINE FOR 16BIT MAX NUMBERS
MOV AX,DX
MOV DI,4		;MAX 5 CHARS
 MOV CX,10           
    ASC2:
	XOR DX,DX
	DIV CX	       ;DIV AX/10
	ADD DX,48	       ;ADD 48 TO REMAINDER TO GET ASCII CHARACTER OF NUMBER
	MOV OUT_STRING[DI],DL
	DEC DI
	CMP AX,0
	JZ EXTT4	       ;IF AX=0, END OF THE PROCEDURE
	JMP ASC2	       ;ELSE REPEAT
    EXTT4:
MOV AH,2
MOV DL,10
INT 21H
MOV DX,OFFSET OUT_STRING	
 MOV AH,09H
INT 21H

JMP RESTART
;========================================== ITEM5 =====================================================	
ITEM5:
MOV DX,OFFSET TASKFIVE
MOV AH,09H
INT 21H	
LEA DX,SEARCH1		;RECEIVE day
	MOV AH,0AH
	INT 21H
	MOV AL,SEARCH1[2]		;CONV. TO NUMBER
	SUB AL,'0'
	MOV CL,10
	MUL CL  
	MOV CL,SEARCH1[3]
	SUB CL,'0'
	ADD AL,CL
	MOV SEARCH_DAY,AL

MOV DX,OFFSET TASKTHREE
MOV AH,09H
INT 21H	
LEA DX,SEARCH1		;RECEIVE mon
	MOV AH,0AH
	INT 21H
	MOV AL,SEARCH1[2]		;CONV. TO NUMBER
	SUB AL,'0'
	MOV CL,10
	MUL CL  
	MOV CL,SEARCH1[3]
	SUB CL,'0'
	ADD AL,CL
	MOV SEARCH_MON,AL	
	


	MOV CX,N_RECORDS
	XOR SI,SI
	XOR DX,DX
	DAYMONLOOP: LEA AX,CANTEEN_CHARGES_DATABASE[SI]
		PUSH AX
		CALL read_rec
		POP AX
		CMP MON,0		;IF MON=0 RECORD NON VALID->DATABASE ENDED
		JE END5
		CMP EMPL,0
		JE END5
		MOV AL,SEARCH_DAY
		MOV AH,SEARCH_MON
		MOV BL,DAY
		MOV BH,MON
		CMP AX,BX 			;IF BOTH MONTH AND DAY ARE CORRECT, ADD THE CURRENT CHARGE TO THE TOTAL
		JNE NEXT_DAYMON
		ADD DX,CHARGE
		NEXT_DAYMON:
		ADD SI,3
		LOOP DAYMONLOOP
END5:MOV DAYMON,DX

;PRINT ROUTINE FOR 16BIT MAX NUMBERS
MOV AX,DX
MOV DI,4		;MAX 5 CHARS
 MOV CX,10           
    ASC25:
	XOR DX,DX
	DIV CX	       ;DIV AX/10
	ADD DX,48	       ;ADD 48 TO REMAINDER TO GET ASCII CHARACTER OF NUMBER
	MOV OUT_STRING[DI],DL
	DEC DI
	CMP AX,0
	JZ EXTT5	       ;IF AX=0, END OF THE PROCEDURE
	JMP ASC25	       ;ELSE REPEAT
    EXTT5:
MOV AH,2
MOV DL,10
INT 21H
MOV DX,OFFSET OUT_STRING	
 MOV AH,09H
INT 21H

JMP RESTART
;==========================================================================================

THE_END:	
	.EXIT
	
read_rec PROC 


		PUSH BP
		MOV BP,SP
		MOV BX,[BP+4] ;ADDRESS OF PUSHED RECORD'S 1ST BYTE
		PUSH CX
		
		;SINCE DATA IS SCRAMBLED UPON 3 BYTES I MADE THIS PROCEDURE TO MAKE SOME ORDER 
		;TO MAKE THINGS EASIER : I PUT EVERY PIECE OF THE RECORD IN A DIFFERENT GLOBAL VARIABLE
		; MON   DAY   EMPL  CHARGE
		;|----|-----|-----|----------|
		;|---- ----|--------|--------|
		; 3RD BYTE    2ND      1ST
		; [BX+2]     [BX+1]    [BX]

		;EXTRACT CHARGES
		MOV AX, [BX]
		AND AX,03FFH ;PUTS TO ZERO USELESS (NON REFERRED TO CHARGES) BITS  --> EXTRACTS THE VALUE FOR CHARGES OF THIS RECORD
		MOV CHARGE,AX
		;EXTRACT EMPLOYEE
		MOV AL,[BX+1]  ;(RECORD'S 2ND BYTE)
		MOV CL,2
		SHR AX,CL
		AND AL,00011111B
		MOV EMPL,AL
		;EXTRACT DAY
		MOV AX,[BX+1] ; AH= 3RD BYTE , AL= 2ND BYTE
		MOV CL,7
		SHR AX,CL
		AND AL,00011111B
		MOV DAY,AL
		;EXTRACT MONTH
		MOV AL,[BX+2]
		MOV CL,4
		SHR AX,CL
		AND AL,00001111B
		MOV MON,AL
		
		POP CX
		POP BP
		RET
read_rec ENDP

WRITE_rec PROC 
		PUSH BP
		MOV BP,SP
		MOV BX,[BP+4] ;ADDRESS OF PUSHED RECORD'S 1ST BYTE
		PUSH CX
		PUSH DX
		;WE GOT TO SCRAMBLE DATA THIS WAY
		; MON   DAY   EMPL  CHARGE
		;|----|-----|-----|----------|
		;|---- ----|--------|--------|
		; 3RD BYTE    2ND      1ST
		; [BX+2]     [BX+1]    [BX]

		;DAY AND MONTH
		MOV AL,DAY
		SHR AL,1
		MOV AH,MON
		MOV CL,4
		SHL AH,CL
		ADD AL,AH
		MOV [BX+2],AL
		XOR AX,AX
		;2ND BYTE
		MOV AL,DAY
		MOV CL,7
		SHL AL,CL
		ADD AH,AL
		MOV DL,EMPL
		MOV CL,2
		SHL DL,CL
		ADD AH,DL
		MOV AL,AH
		XOR AH,AH
		MOV DX,CHARGE
		MOV CL,8
		SHR DX,CL
		ADD AX,DX
		MOV [BX+1],AL
		;3RD
		MOV AX,CHARGE
		MOV [BX],AL
		
		POP DX
		POP CX
		POP BP
		RET
WRITE_rec ENDP		
		
	END
		
