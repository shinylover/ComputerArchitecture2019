; CAS20110225.PDF
; SUMMER OLYMPIC GAMES
; BY WAQAR HASSAN S197729

NUM_OF_ATHLETES EQU 8 
ARRAY_LIMIT EQU NUM_OF_ATHLETES*3
.8086
.MODEL SMALL
.STACK 100H
.DATA

	TIMES DB 00000110B ,01101110B,01100110B , 00000101B ,01001011B,00010101B , 00000011B ,00111111B,11011100B , 00000010B ,00101111B,10010100B , 00000111B ,01011111B,10110011B , 00000000B ,00101111B,01110011B , 00000001B ,10101011B,01101011B , 00000100B ,00000111B,01000011B ; INPUT ARRAY
	STANDINGS DB NUM_OF_ATHLETES DUP (?, ?, ?) ; ARRAY FOR STANDINGS
	DIFF_PREV DW NUM_OF_ATHLETES DUP (?) ; ARRAY FOR TIME DIFFERENCE FROM PREVIOUS ATHLETE
	DIFF_FIRST DW NUM_OF_ATHLETES DUP (?) ; ARRAY FOR TIME DIFFERENCE FROM FIRST ATHLETE
	DIFF_WR DW ? ; TIME DIFFERENCE OF WINNER FROM WORLD RECORD
	WR DW 0000111101000011B ; CURRENT WORLD RECORD

	;STRING MESSAGES
	STRING_STANDINGS DB "STANDINGS (FORMAT: ATHLETE NUMBER,MIN,SEC,100TH SEC) $"
	STRING_WR DB "WORLD RECORD HAS BEEN BROKEN BY ATHLETE NUMBER : $"
	STRING_DIFF_PREV DB "DIFFERENCE FROM PREVIOUS ATHLETE (FORMAT: MIN,SEC,100TH SEC) $"
	STRING_DIFF_FIRST DB "DIFFERENCE FROM WINNER (FORMAT: MIN,SEC,100TH SEC) $"
	STRING_DIFF_WR DB "DIFFERENCE FROM WORLD RECORD (FORMAT: MIN,SEC,100TH SEC) $"

	UNPACKED DB NUM_OF_ATHLETES DUP (?,?,?) ; ARRAY TO UNPACK TIMES IN THE FORMAT NNNNNNNN MMMSSSSS SHHHHHHH (WHERE N REPRESENTS A BIT OF ATHLETE NUMBER, M MIN, S SEC AND H 100TH SEC RESPECTIVELY)
	SEPERATE_TIME DB NUM_OF_ATHLETES DUP (?,?,?) ; ARRAY TO UPACK AND SEPERATE SORTED TIME IN THE FORMAT 0HHHHHHH 00SSSSSS 00000MMM (WHERE M REPRESENTS A BIT OF MINUTES, S SECONDS AND H 100TH SECONDS RESPECTIVELY)

.CODE
.STARTUP
	MAIN PROC; STARTING THE MAIN PROCEDURE
		CALL UNPACKING; CALL THE PROCEDURE TO UNPACK TIMES TO UNPAKCED
			; COPY ENTIRE CONTENTS OF UNPACKED TO STANDINGS
			XOR SI,SI
			ARRAY_COPY:
			MOV AL,UNPACKED[SI]
			MOV STANDINGS[SI],AL
			INC SI
			CMP SI,ARRAY_LIMIT
			JNE ARRAY_COPY
		CALL SORT; CALL THE PROCEDURE TO SORT STANDINGS IN ASCENDING ORDER
		CALL PACKING; CALL THE PROCEDURE TO PACK STANDINGS TO STANDARD FORMAT
		CALL DISPLAY_STANDINGS; CALL THE PROCEDURE TO DISPLAY CONENTS OF STANDINGS
		
		CALL SEP_TIME; CALL THE PROCEDURE TO UNPACK AND SEPERATE TIME FROM STANDINGS TO SEPERATE_TIME
		
		CALL CALC_DIFF_PREV; CALL THE PROCEDURE TO CALCULATE TIME DIFFERENCE FROM PREVIOUS ATHLETE
		CALL DISPLAY_DIFF_PREV ; CALL THE PROCEDURE TO DISPLAY TIME DIFFERENCE FROM PREVIOUS ATHLETE
		
		CALL CALC_DIFF_FIRST; CALL THE PROCEDURE TO CALCULATE TIME DIFFERENCE FROM FIRST ATHLETE
		CALL DISPLAY_DIFF_FIRST; CALL THE PROCEDURE TO DISPLAY TIME DIFFERENCE FROM FIRST ATHLETE
		
		CALL CALC_DIFF_WR; CALL THE PROCEDURE TO CALCULATE TIME DIFFERENCE OF WINNER FROM WORLD RECORD
		CALL DISPLAY_DIFF_WR; CALL THE PROCEDURE TO DISPLAY TIME DIFFERENCE OF WINNER FROM WORLD RECORD
		
		JMP ENDALL; EXIT     
	MAIN ENDP   

	UNPACKING PROC; PROCEDURE FOR UNPACKING TIMES TO UNPAKCED
		XOR SI,SI; SI = 0
		UNPACKING_LOOP:
			MOV AL,TIMES[SI] ; AL = ATHLETE NUMBER
			MOV UNPACKED[SI],AL ; TRANSFER AL AS IT IS TO UNPACKED
			MOV AX, WORD PTR TIMES[SI+1] ; AX = HHHHHHHS SSSSSMMM
			TEST AH,08H; CHECK IF HHHHHHHS SSSS"S"MMM BIT IS HIGH
			JZ UNPACKING_NO_CARRY ; JUMP IF NOT HIGH
				STC ; CF = 1
			UNPACKING_NO_CARRY:
			RCR AL,1 ; AL = SHHHHHHH
			; RCL AH,5
			RCL AH,1 
			RCL AH,1 
			RCL AH,1 
			RCL AH,1 
			RCL AH,1 ; AH = MMMSSSSS
			MOV UNPACKED[SI+1],AH ; TRANSFER AH TO UNPACKED
			MOV UNPACKED[SI+2],AL ; TRANSFER AL TO UNPACKED
			ADD SI,3 ; SI = SI +3
			CMP SI, ARRAY_LIMIT; CHECK IF NEXT ITERATION IS REQUIRED
			JNE UNPACKING_LOOP; LOOP AGAIN BASED ON PREVIOUS CONDITION
		RET
	UNPACKING ENDP

	SORT PROC ; PROCEDURE FOR SORTING STANDINGS IN ASCENDING ORDER
		PUSH AX; SAVE REGISTERS
		PUSH BX; SAVE REGISTERS
		PUSH CX; SAVE REGISTERS
		PUSH DX; SAVE REGISTERS
		XOR DI,DI ; DI = 0 (WILL BE USED AS A COUNTER FOR NUMBER OF SORTINGS PERFORMED)
		SORT_OUT_LOOP:    
			XOR SI,SI ; SI = 0
			SORT_IN_LOOP:   
				MOV CH,STANDINGS[SI] ; CH = NNNNNNNN (CURRENT ATHLETE)
				MOV CL,STANDINGS[SI+3] ; CL = NNNNNNNN (NEXT ATHLETE)
				MOV AH,STANDINGS[SI+1] ; AH = MMMSSSSS (CURRENT ATHLETE)
				MOV AL,STANDINGS[SI+2] ; AL = SHHHHHHH (CURRENT ATHLETE)
				MOV BH,STANDINGS[SI+4] ; BH = MMMSSSSS (NEXT ATHLETE)
				MOV BL,STANDINGS[SI+5] ; BL = SHHHHHHH (NEXT ATHLETE)
				CMP AX,BX ; COMPARE AX AND BX
				JB NO_SWAP ; JUMP IF AX < BX (NO SWAP REQUIRED)
					XCHG AX,BX ; SWAP ATHLETE TIMEINGS
					XCHG CL,CH ; SWAP ATHLETE NUMBERS
					MOV STANDINGS[SI],CH ; SAVE SWAPED ATHLETE NUMBER (NEXT ATHLETE)
					MOV STANDINGS[SI+3],CL ; SAVE SWAPED ATHLETE NUMBER (CURRENT ATHLETE)
					MOV STANDINGS[SI+1],AH ; SAVE SWAPED ATHLETE TIMINGS (NEXT ATHL	ETE)
					MOV STANDINGS[SI+2],AL ; SAVE SWAPED ATHLETE TIMINGS (NEXT ATHLETE)
					MOV STANDINGS[SI+4],BH ; SAVE SWAPED ATHLETE TIMINGS (CURRENT ATHLETE)
					MOV STANDINGS[SI+5],BL ; SAVE SWAPED ATHLETE TIMINGS (CURRENT ATHLETE)
				NO_SWAP:
				ADD SI,3 ; SI = SI + 3
				CMP SI,ARRAY_LIMIT-3 ; CHECK IF NEXT ITERATION IS REQUIRED
				JNE SORT_IN_LOOP ; LOOP AGAIN BASED ON PREVIOUS CONDITION
			INC DI ; DI = DI + 1
			CMP DI,NUM_OF_ATHLETES-1 ; CHECK IF SORTING AGAIN IS REQUIRED
			JNE SORT_OUT_LOOP ; LOOP AGAIN BASED ON PREVIOUS CONDITION
		POP DX; RETRIEVE REGISTERS
		POP CX; RETRIEVE REGISTERS
		POP BX; RETRIEVE REGISTERS
		POP AX; RETRIEVE REGISTERS
		RET
	SORT ENDP

	PACKING PROC ; PROCEDURE FOR PACKING STANDINGS TO STANDARD FORMAT
		XOR SI,SI ; SI = 0
		PACKING_LOOP:
			MOV AX, WORD PTR STANDINGS[SI+1] ; AX = MMMSSSSS SHHHHHHH
			TEST AL,10H ; CHECK IF MMM"S"SSSS SHHHHHHH BIT IS HIGH
			JZ PACKING_NO_CARRY ; JUMP IF NOT HIGH
				STC ; CF = 1
			PACKING_NO_CARRY:
			RCL AH,1 ; AH = HHHHHHHS
			;RCR AL,5
			RCR AL,1
			RCR AL,1
			RCR AL,1
			RCR AL,1
			RCR AL,1 ; AL = SSSSSMMM
			MOV STANDINGS[SI+1],AH ; TRANSFER AH TO STANDINGS
			MOV STANDINGS[SI+2],AL ; TRANSFER AL TO STANDINGS
			ADD SI,3 ; SI = SI + 3
			CMP SI, ARRAY_LIMIT ; CHECK IF NEXT ITERATION IS REQUIRED
			JNE PACKING_LOOP ; LOOP AGAIN BASED ON PREVIOUS CONDITION   
		RET
	PACKING ENDP 

	SEP_TIME PROC ; PROCEDURE FOR UNPACKING AND SEPERATING TIME FROM STANDINGS TO SEPERATE_TIME
		PUSH AX; SAVE REGISTERS
		PUSH BX; SAVE REGISTERS
		PUSH CX; SAVE REGISTERS
		PUSH DX; SAVE REGISTERS
		XOR SI,SI ; SI = 0
		SEP_TIME_LOOP:
			MOV AH, STANDINGS [SI+1] ; AH = HHHHHHHS
			MOV AL, STANDINGS [SI+2] ; AL = SSSSSMMM
			; SEPERATING 100TH SECONDS
			MOV BX,AX ; BX = AX
			AND BX,0FE00H ; BX = HHHHHHH0 00000000
			; SHR BX,9
			SHR BX,1
			SHR BX,1
			SHR BX,1
			SHR BX,1
			SHR BX,1
			SHR BX,1
			SHR BX,1
			SHR BX,1
			SHR BX,1 ; BX = 00000000 0HHHHHHH
			MOV SEPERATE_TIME[SI],BL ; SAVE BL TO SEPERATE_TIME
			; SEPERATING SECONDS
			MOV BX,AX ; BX = AX
			AND BX,01F8H ; BX = 0000000S SSSSS000
			;SHR BX,3
			SHR BX,1
			SHR BX,1
			SHR BX,1 ; BX = 00000000 00SSSSSS
			MOV SEPERATE_TIME[SI+1],BL ; SAVE BL TO SEPERATE_TIME
			; SEPERATING MINUTES
			MOV BX,AX ; BX = AX
			AND BX,0007H ; BX = 00000000 00000MMM
			MOV SEPERATE_TIME[SI+2],BL ; SAVE BL TO SEPERATE_TIME
			
			ADD SI,3 ; SI = SI + 3
			CMP SI,ARRAY_LIMIT ; CHECK IF NEXT ITERATION IS REQUIRED
			JNE SEP_TIME_LOOP ; LOOP AGAIN BASED ON PREVIOUS CONDITION
		POP DX; RETRIEVE REGISTERS
		POP CX; RETRIEVE REGISTERS
		POP BX; RETRIEVE REGISTERS
		POP AX; RETRIEVE REGISTERS
		RET
	SEP_TIME ENDP

	CALC_DIFF_PREV PROC ; PROCEDURE FOR CALCULATING TIME DIFFERENCE FROM PREVIOUS ATHLETE
		XOR SI,SI ; SI = 0
		MOV DI,2 ; DI = 2
		DIFF_PREV_LOOP:
			MOV CL, SEPERATE_TIME[SI] ; CL = 0HHHHHHH (CURRENT ATHELETE)
			MOV CH, SEPERATE_TIME[SI+3] ; CH = 0HHHHHHH (NEXT ATHELETE)
			MOV BL, SEPERATE_TIME[SI+1] ; BL = 00SSSSSS (CURRENT ATHLETE)
			MOV BH, SEPERATE_TIME[SI+4] ; BH = 00SSSSSS (NEXT ATHLETE)
			MOV AL, SEPERATE_TIME[SI+2] ; AL = 00000MMM (CURRENT ATHLETE)
			MOV AH, SEPERATE_TIME[SI+5] ; AH = 00000MMM (NEXT ATHLETE)
			; SUBTRACTING 100TH SECONDS
			CMP CH,CL ; COMPARE CH AND CL
			JAE DIFF_PREV_HSEC ; JUMP IF CH >= CL (NORMAL SUBTRACTION POSSIBLE)
				SUB BH,1 ; BH = BH - 1
				ADD CH,100 ; CH = CH + 100
			DIFF_PREV_HSEC:
			SUB CH,CL ; CH = CH - CL
			; SUBTRACTING SECONDS
			CMP BH,BL ; COMPARE BH AND BL
			JAE DIFF_PREV_SEC ; JUMP IF BH >= BL (NORMAL SUBTRACTION POSSIBLE)
				SUB AH,1 ; AH = AH - 1
				ADD BH,60 ; BH = BH + 60
			DIFF_PREV_SEC:
			SUB BH,BL ; BH = BH - BL
			; SUBTRACTING MINTUES
			SUB AH,AL ; AH = AH - AL
			; REPACKING TIMINGS
			XOR AL,AL ; AL = 0
			XOR BL,BL ; BL = 0
			XOR CL,CL ; CL = 0
			XCHG AH,AL ; AX = 00000000 00000MMM
			XCHG BH,BL ; BX = 00000000 00SSSSSS
			XCHG CH,CL ; CX = 00000000 0HHHHHHH
			; SHL BX,3
			SHL BX,1
			SHL BX,1
			SHL BX,1 ; BX = 0000000S SSSSS000
			; SHL CX,9
			SHL CX,1
			SHL CX,1
			SHL CX,1
			SHL CX,1
			SHL CX,1
			SHL CX,1
			SHL CX,1
			SHL CX,1
			SHL CX,1 ; CX = HHHHHHH0 00000000
			OR AX,BX ; AX = 0000000S SSSSSMMM
			OR AX,CX ; AX = HHHHHHHS SSSSSMMM
			MOV BYTE PTR DIFF_PREV[DI+1], AH ; SAVE AH TO DIFF_PREV
			MOV BYTE PTR DIFF_PREV[DI], AL ; SAVE AL TO DIFF_PREV
			
			ADD DI,2 ; DI = DI + 2
			ADD SI,3 ; SI = SI + 3
			CMP SI,ARRAY_LIMIT-3 ; CHECK IF NEXT ITERATION IS REQUIRED
			JNE DIFF_PREV_LOOP ; LOOP AGAIN BASED ON PREVIOUS CONDITION
		RET
	CALC_DIFF_PREV ENDP


	CALC_DIFF_FIRST PROC ; PROCEDURE FOR CALCULATING TIME DIFFERENCE FROM FIRST ATHLETE
		XOR SI,SI ; SI = 0
		MOV DI,2 ; DI = 2
		DIFF_FIRST_LOOP:
			MOV CL, SEPERATE_TIME[0] ; CL = 0HHHHHHH (FIRST ATHELETE)
			MOV CH, SEPERATE_TIME[SI+3] ; CH = 0HHHHHHH (CURRENT ATHELETE)
			MOV BL, SEPERATE_TIME[1] ; BL = 00SSSSSS (FIRST ATHLETE)
			MOV BH, SEPERATE_TIME[SI+4] ; BH = 00SSSSSS (CURRENT ATHLETE)
			MOV AL, SEPERATE_TIME[2] ; AL = 00000MMM (FIRST ATHLETE)
			MOV AH, SEPERATE_TIME[SI+5] ; AH = 00000MMM (CURRENT ATHLETE)
			; SUBTRACTING 100TH SECONDS
			CMP CH,CL ; COMPARE CH AND CL
			JAE DIFF_FIRST_HSEC ; JUMP IF CH >= CL (NORMAL SUBTRACTION POSSIBLE)
				SUB BH,1 ; BH = BH - 1
				ADD CH,100 ; CH = CH + 100
			DIFF_FIRST_HSEC:
			SUB CH,CL; CH = CH - CL
			; SUBTRACTING SECONDS
			CMP BH,BL ; COMPARE BH AND BL
			JAE DIFF_FIRST_SEC ; JUMP IF BH >= BL (NORMAL SUBTRACTION POSSIBLE)
				SUB AH,1 ; AH = AH - 1
				ADD BH,60 ; BH = BH + 60
			DIFF_FIRST_SEC:
			SUB BH,BL ; BH = BH - BL
			; SUBTRACTING MINTUES
			SUB AH,AL ; AH = AH - AL
			; REPACKING TIMINGS
			XOR AL,AL ; AL = 0
			XOR BL,BL ; BL = 0
			XOR CL,CL ; CL = 0
			XCHG AH,AL ; AX = 00000000 00000MMM
			XCHG BH,BL ; BX = 00000000 00SSSSSS
			XCHG CH,CL ; CX = 00000000 0HHHHHHH
			; SHL BX,3
			SHL BX,1
			SHL BX,1
			SHL BX,1 ; BX = 0000000S SSSSS000
			; SHL CX,9
			SHL CX,1
			SHL CX,1
			SHL CX,1
			SHL CX,1
			SHL CX,1
			SHL CX,1
			SHL CX,1
			SHL CX,1
			SHL CX,1 ; CX = HHHHHHH0 00000000
			OR AX,BX ; AX = 0000000S SSSSSMMM
			OR AX,CX ; AX = HHHHHHHS SSSSSMMM
			MOV BYTE PTR DIFF_FIRST[DI+1], AH ; SAVE AH TO DIFF_FIRST
			MOV BYTE PTR DIFF_FIRST[DI], AL ; SAVE AH TO DIFF_FIRST
			
			ADD DI,2 ; DI = DI + 2
			ADD SI,3 ; SI = SI + 3
			CMP SI,ARRAY_LIMIT-3 ; CHECK IF NEXT ITERATION IS REQUIRED
			JNE DIFF_FIRST_LOOP ; LOOP AGAIN BASED ON PREVIOUS CONDITION
		RET
	CALC_DIFF_FIRST ENDP

	CALC_DIFF_WR PROC ; PROCEDURE FOR CALCULATING TIME DIFFERENCE OF WINNER FROM WORLD RECORD
		PUSH AX; SAVE REGISTERS
		PUSH BX; SAVE REGISTERS
		PUSH CX; SAVE REGISTERS
		PUSH DX; SAVE REGISTERS
		MOV AX, WR ; AX = WORLD RECORD
		;SEPERATING 100TH SECONDS
		MOV BX,AX ; BX = AX
		AND BX,0FE00H ; BX = HHHHHHH0 00000000
		; SHR BX,9
		SHR BX,1
		SHR BX,1
		SHR BX,1
		SHR BX,1
		SHR BX,1
		SHR BX,1
		SHR BX,1
		SHR BX,1
		SHR BX,1 ; BX = 00000000 0HHHHHHH
		;SEPERATING SECONDS
		MOV CX,AX ; CX = AX
		AND CX,01F8H ; CX = 0000000S SSSSS000
		; SHR CX,3
		SHR CX,1
		SHR CX,1
		SHR CX,1 ; CX = 00000000 00SSSSSS
		; SEPERATING MINUTES
		MOV DX,AX ; DX = AX
		AND DX,0007H ; DX = 00000000 00000MMM
		
		MOV BH, SEPERATE_TIME[0] ; BH = 100 TH SECONDS OF WINNER
		MOV CH, SEPERATE_TIME[1] ; CH = SECONDS OF WINNER
		MOV DH, SEPERATE_TIME[2] ; DH = MINUTES OF WINNER
		
		; CHECK IF WORLD RECORD IS BROKEN OR NOT
		CMP DH,DL ; COMPARE DH AND DL
		JB WR_BROKEN ; JUMP IF DH < DL ( WORLD RECORD BROKEN )
		JA WR_NOT_BROKEN_CALC_DIFF ; JUMP IF DH > DL ( WORLD RECORD NOT BORKEN )
		CMP CH,CL ; COMPARE CH AND CL
		JB WR_BROKEN ; JUMP IF CH < CL ( WORLD RECORD BROKEN )
		JA WR_NOT_BROKEN_CALC_DIFF ; JUMP IF CH > CL ( WORLD RECORD NOT BORKEN )
		CMP BH,BL ; COMPARE BH AND BL
		JB WR_BROKEN ; JUMP IF BH < BL ( WORLD RECORD BROKEN )
		JA WR_NOT_BROKEN_CALC_DIFF ; JUMP IF BH > BL ( WORLD RECORD NOT BORKEN )
		WR_BROKEN:
			XCHG BH,BL ; SWAP BH AND BL
			XCHG CH,CL ; SWAP CH AND CL
			XCHG DH,DL ; SWAP DH AND DL
			MOV AH, STANDINGS [1] ; AH = HHHHHHHS (OF NEW WORLD RECORD)
			MOV AL, STANDINGS [2] ; AL = SSSSSMMM (OF NEW WORLD RECORD)
			MOV WR,AX ; UPDATE WR WITH NEW WORD RECORD
			;DISPLAY WORLD RECORD BROKEN
			PUSH AX; SAVE REGISTERS
			PUSH BX; SAVE REGISTERS
			PUSH CX; SAVE REGISTERS
			PUSH DX; SAVE REGISTERS
			MOV AH,09H ; PREPARE AH FOR STRING OUTPUT
			MOV DX,OFFSET STRING_WR; Prepare DX with offset of String to display
			INT 21H ; CALL INTERRUPT
			MOV DL, STANDINGS[0] ; DL = ATHLETE NUMBER OF NEW WORLD RECORD HOLDER
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H ; PREPARE AH FOR CHARACTER OUTPUT
			INT	21H ; CALL INTERUPT
			MOV AH,02H ; PREPARE AH FOR CHARACTER OUTPUT
			MOV DL,0DH ; DL = CARRIAGE RETURN
			INT 21H ; CALL INTERRUPT
			MOV DL,0AH ; DL = LINE FEED
			INT 21H ; CALL INTERRUPT
			POP DX; RETRIEVE REGISTERS
			POP CX; RETRIEVE REGISTERS
			POP BX; RETRIEVE REGISTERS
			POP AX; RETRIEVE REGISTERS
		WR_NOT_BROKEN_CALC_DIFF:
		; SUBTRACTING 100TH SECONDS
		CMP BH,BL ; COMPARE BH AND BL
		JAE DIFF_WR_HSEC ; JUMP IF BH >= BL (NORMAL SUBTRACTION POSSIBLE)
			SUB CH,1 ; CH = CH - 1
			ADD BH,100 ; BH = BH + 100
		DIFF_WR_HSEC:
		SUB BH,BL; BH = BH - BL
		; SUBTRACTING SECONDS
		CMP CH,CL ; COMPARE CH AND CL
		JAE DIFF_WR_SEC ; JUMP IF CH >= CL (NORMAL SUBTRACTION POSSIBLE)
			SUB DH,1 ; DH = DH - 1
			ADD CH,60 ; CH = CH + 60
		DIFF_WR_SEC:
		SUB CH,CL ; CH = CH - CL
		; SUBTRACTING MINUTES
		SUB DH,DL ; DH = DH - DL
		; PACKING TIMINGS
		XOR BL,BL ; BL = 0
		XOR CL,CL ; CL = 0
		XOR DL,DL ; DL = 0
		XCHG BH,BL ; BX = 00000000 0HHHHHHH
		XCHG CH,CL ; CX = 00000000 00SSSSSS
		XCHG DH,DL ; DX = 00000000 00000MMM
		; SHL CX,3
		SHL CX,1
		SHL CX,1
		SHL CX,1 ; CX = 0000000S SSSSS000
		; SHL BX,9
		SHL BX,1
		SHL BX,1
		SHL BX,1
		SHL BX,1
		SHL BX,1
		SHL BX,1
		SHL BX,1
		SHL BX,1
		SHL BX,1 ; BX = HHHHHHH0 00000000
		OR BX,CX ; BX = 0000000S SSSSSMMM
		OR BX,DX ; BX = HHHHHHHS SSSSSMMM
		MOV DIFF_WR, BX ; SAVE BX TO DIFF_WR
		POP DX; RETRIEVE REGISTERS
		POP CX; RETRIEVE REGISTERS
		POP BX; RETRIEVE REGISTERS
		POP AX; RETRIEVE REGISTERS
		RET
	CALC_DIFF_WR ENDP

	; DISPLAY PROCEDURES

	DISPLAY_STANDINGS PROC ; PROCEDURE FOR DISPLAYING CONENTS OF STANDINGS
		PUSH AX; SAVE REGISTERS
		PUSH BX; SAVE REGISTERS
		PUSH CX; SAVE REGISTERS
		PUSH DX; SAVE REGISTERS
		MOV AH,09H ; PREPARE AH FOR STRING OUTPUT
		MOV DX,OFFSET STRING_STANDINGS; PREPARE DX WITH OFFSET OF STRING TO DISPLAY
		INT 21H; CALL INTERRUPT
		
		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		MOV DL,0DH ; DL = CARRIAGE RETURN
		INT 21H; CALL INTERRUPT
		MOV DL,0AH; DL = LINE FEED
		INT 21H; CALL INTERRUPT
		
		XOR SI,SI ; SI = 0
		DISP_STANDINGS_LOOP:
			;DISPLAYING ATHLETE NUMBER
			MOV DL, STANDINGS[SI] ; DL = NNNNNNNN
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV	AH, 02H ; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			MOV DL, ',' ; DL = ,
			MOV	AH, 02H ; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			; DISPLAYING MINUTES
			MOV DL,STANDINGS[SI+2] ; DL = SSSSSMMM
			AND DL,07H ; DL = 00000MMM
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV	AH, 02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H; CALL INTERRUPT
			MOV DL, ',' ; DL = ,
			MOV	AH, 02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H; CALL INTERRUPT
			; DISPLAYING SECONDS
			MOV AH,STANDINGS[SI+1] ; AH = HHHHHHHS
			MOV AL,STANDINGS[SI+2] ; AL = SSSSSMMM
			AND AX,1F8H ; AX = 0000000S SSSSS000
			; SHR AX,3
			SHR AX,1
			SHR AX,1
			SHR AX,1 ; AX = 00000000 00SSSSSS
			MOV BX, 10; BX = 10
			XOR DX, DX; DX = 0
			DIV BX; DIVIDE TO SEPERATE DIGITS ( DL = RIGHT DIGIT , AL = LEFT DIGIT )
			MOV BL,DL ; BL = DL
			MOV DL,AL ; DL = AL
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			MOV DL,BL ; DL = BL
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			MOV DL, ',' ; DL = ,
			MOV	AH, 02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			; DISPLAYING 100TH SECONDS
			MOV AL,STANDINGS[SI+1] ; AL = HHHHHHHS
			AND AL,0FEH ; AL = HHHHHHH0
			SHR AL,1 ; AL = 0HHHHHHH
			XOR AH,AH ; AH = 0
			MOV BX, 10; BX = 10
			XOR DX, DX; DX = 0
			DIV BX; DIVIDE TO SEPERATE DIGITS ( DL = RIGHT DIGIT , AL = LEFT DIGIT )
			MOV BL,DL ; BL = DL
			MOV DL,AL ; DL = AL
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			MOV DL,BL ; DL = BL
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			MOV DL,0DH ; DL = CARRIAGE RETURN
			INT 21H; CALL INTERRUPT
			MOV DL,0AH; DL = LINE FEED
			INT 21H; CALL INTERRUPT
			
			ADD SI,3 ; SI = SI + 3
			CMP SI,ARRAY_LIMIT ; CHECK IF NEXT ITERATION IS REQUIRED
			JNE DISP_STANDINGS_LOOP ; LOOP AGAIN BASED ON PREVIOUS CONDITION
		POP DX; RETRIEVE REGISTERS
		POP CX; RETRIEVE REGISTERS
		POP BX; RETRIEVE REGISTERS
		POP AX; RETRIEVE REGISTERS
		RET
	DISPLAY_STANDINGS ENDP

	DISPLAY_DIFF_PREV PROC ; PROCEDURE FOR DISPLAYING TIME DIFFERENCE FROM PREVIOUS ATHLETE
		PUSH AX; SAVE REGISTERS
		PUSH BX; SAVE REGISTERS
		PUSH CX; SAVE REGISTERS
		PUSH DX; SAVE REGISTERS
		MOV AH,09H ; PREPARE AH FOR STRING OUTPUT
		MOV DX,OFFSET STRING_DIFF_PREV; PREPARE DX WITH OFFSET OF STRING TO DISPLAY
		INT 21H; CALL INTERRUPT
		
		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		MOV DL,0DH ; DL = CARRIAGE RETURN
		INT 21H; CALL INTERRUPT
		MOV DL,0AH; DL = LINE FEED
		INT 21H; CALL INTERRUPT
		
		XOR SI,SI ; SI = 0
		DISP_DIFF_PREV_LOOP:
			; DISPLAYING MINUTES
			MOV DL,BYTE PTR DIFF_PREV[SI] ; DL = SSSSSMMM
			AND DL,07H ; DL = 00000MMM
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H; CALL INTERRUPT
			MOV DL, ',' ; DL = ,
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H; CALL INTERRUPT
			; DISP	LAYING SECONDS
			MOV AX, DIFF_PREV[SI] ; AX = HHHHHHHS SSSSSMMM
			AND AX, 1F8H ; AX = 0000000S SSSSS000
			; SHR AX, 3
			SHR AX, 1
			SHR AX, 1
			SHR AX, 1 ; AX = 00000000 00SSSSSS
			MOV BX, 10; BX = 10
			XOR DX, DX; DX = 0
			DIV BX; DIVIDE TO SEPERATE DIGITS ( DL = RIGHT DIGIT , AL = LEFT DIGIT )
			MOV BL,DL ; BL = DL
			MOV DL,AL ; DL = AL
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H; CALL INTERRUPT
			MOV DL,BL ; DL = BL
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H; CALL INTERRUPT
			MOV DL, ',' ; DL = ,
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H; CALL INTERRUPT
			; DISPLAYING 100TH SECONDS
			MOV AL,BYTE PTR DIFF_PREV[SI+1] ; AL = HHHHHHHS
			AND AL,0FEH ; AL = HHHHHHH0
			SHR AL,1 ; AL = 0HHHHHHH
			XOR AH,AH ; AH = 0
			MOV BX, 10; BX = 10
			XOR DX, DX; DX = 0
			DIV BX; DIVIDE TO SEPERATE DIGITS ( DL = RIGHT DIGIT , AL = LEFT DIGIT )
			MOV BL,DL ; BL = DL
			MOV DL,AL ; DL = AL
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H; CALL INTERRUPT
			MOV DL,BL ; DL = BL
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H ; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			MOV DL,0DH ; DL = CARRIAGE RETURN
			INT 21H; CALL INTERRUPT
			MOV DL,0AH ; DL = LINE FEED
			INT 21H ; CALL INTERRUPT
			
			ADD SI,2 ; SI = SI + 2
			CMP SI,16 ; CHECK IF NEXT ITERATION IS REQUIRED
			JNE DISP_DIFF_PREV_LOOP ; LOOP AGAIN BASED ON PREVIOUS CONDITION
		POP DX; RETRIEVE REGISTERS
		POP CX; RETRIEVE REGISTERS
		POP BX; RETRIEVE REGISTERS
		POP AX; RETRIEVE REGISTERS
		RET
	DISPLAY_DIFF_PREV ENDP

	DISPLAY_DIFF_FIRST PROC
		PUSH AX; SAVE REGISTERS
		PUSH BX; SAVE REGISTERS
		PUSH CX; SAVE REGISTERS
		PUSH DX; SAVE REGISTERS
		MOV AH,09H ; PREPARE AH FOR STRING OUTPUT
		MOV DX,OFFSET STRING_DIFF_FIRST ; PREPARE DX WITH OFFSET OF STRING TO DISPLAY
		INT 21H ; CALL INTERRUPT
		
		MOV AH,02H ; PREPARE AH FOR CHARACTER OUTPUT
		MOV DL,0DH ; DL = CARRIAGE RETURN
		INT 21H ; CALL INTERRUPT
		MOV DL,0AH ; DL = LINE FEED
		INT 21H ; CALL INTERRUPT
		
		XOR SI,SI ; SI = 0
		DISP_DIFF_FIRST_LOOP:
			; DISPLAYING MINUTES
			MOV DL,BYTE PTR DIFF_FIRST[SI] ; DL = SSSSSMMM
			AND DL,07H ; DL = 00000MMM
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			MOV DL, ',' ; DL = ,
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			; DISPLAYING SECONDS
			MOV AX, DIFF_FIRST[SI] ; AX = HHHHHHHS SSSSSMMM
			AND AX, 1F8H ; AX = 0000000S SSSSS000
			; SHR AX, 3
			SHR AX, 1
			SHR AX, 1
			SHR AX, 1 ; AX = 00000000 00SSSSSS
			MOV BX, 10; BX = 10
			XOR DX, DX; DX = 0
			DIV BX; DIVIDE TO SEPERATE DIGITS ( DL = RIGHT DIGIT , AL = LEFT DIGIT )
			MOV BL,DL ; BL = DL
			MOV DL,AL ; DL = AL
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H; CALL INTERRUPT
			MOV DL,BL; DL = BL
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			MOV DL, ',' ; DL = ,
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			; DISPLAYING 100TH SECONDS
			MOV AL,BYTE PTR DIFF_FIRST[SI+1] ; AL = HHHHHHHS
			AND AL,0FEH ; AL = HHHHHHH0
			SHR AL,1 ; AL = 0HHHHHHH
			XOR AH,AH ; AH = 0
			MOV BX, 10; BX = 10
			XOR DX, DX; DX = 0
			DIV BX; DIVIDE TO SEPERATE DIGITS ( DL = RIGHT DIGIT , AL = LEFT DIGIT )
			MOV BL,DL ; BL = DL
			MOV DL,AL ; DL = AL
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H; CALL INTERRUPT
			MOV DL,BL ; DL = BL
			ADD DL, '0' ; CONVERT DIGIT TO ASCII
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT

			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			MOV DL,0DH ; DL = CARRIAGE RETURN
			INT 21H; CALL INTERRUPT
			MOV DL,0AH; DL = LINE FEED
			INT 21H; CALL INTERRUPT

			ADD SI,2 ; SI = SI + 2
			CMP SI,16 ; CHECK IF NEXT ITERATION IS REQUIRED
			JNE DISP_DIFF_FIRST_LOOP ; LOOP AGAIN BASED ON PREVIOUS CONDITION
		POP DX; RETRIEVE REGISTERS
		POP CX; RETRIEVE REGISTERS
		POP BX; RETRIEVE REGISTERS
		POP AX; RETRIEVE REGISTERS
		RET
	DISPLAY_DIFF_FIRST ENDP

	DISPLAY_DIFF_WR PROC
		PUSH AX; SAVE REGISTERS
		PUSH BX; SAVE REGISTERS
		PUSH CX; SAVE REGISTERS
		PUSH DX; SAVE REGISTERS
		MOV AH,09H ; PREPARE AH FOR STRING OUTPUT
		MOV DX,OFFSET STRING_DIFF_WR; PREPARE DX WITH OFFSET OF STRING TO DISPLAY
		INT 21H ; CALL INTERRUPT
		
		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		MOV DL,0DH ; DL = CARRIAGE RETURN
		INT 21H; CALL INTERRUPT
		MOV DL,0AH; DL = LINE FEED
		INT 21H; CALL INTERRUPT
		; DISPLAYING MINUTES
		MOV DL,BYTE PTR DIFF_WR[0] ; DL = SSSSSMMM
		AND DL,07H ; DL = 00000MMM
		ADD DL, '0' ; CONVERT DIGIT TO ASCII
		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		INT 21H ; CALL INTERRUPT
		MOV DL, ',' ; DL = ,
		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		INT 21H ; CALL INTERRUPT
		; DISPLAYING SECONDS
		MOV AX, DIFF_WR[0] ; AX = HHHHHHHS SSSSSMMM
		AND AX, 1F8H ; AX = 0000000S SSSSS000
		; SHR AX, 3
		SHR AX, 1
		SHR AX, 1
		SHR AX, 1 ; AX = 00000000 00SSSSSS
		MOV BX, 10; BX = 10
		XOR DX, DX; DX = 0
		DIV BX; DIVIDE TO SEPERATE DIGITS ( DL = RIGHT DIGIT , AL = LEFT DIGIT )
		MOV BL,DL ; BL = DL
		MOV DL,AL ; DL = AL
		ADD DL, '0' ; CONVERT DIGIT TO ASCII
		MOV AH,02H ; PREPARE AH FOR CHARACTER OUTPUT
		INT 21H ; CALL INTERRUPT
		MOV DL,BL; DL = BL
		ADD DL, '0' ; CONVERT DIGIT TO ASCII
		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		INT 21H ; CALL INTERRUPT
		MOV DL, ',' ; DL = ,
		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		INT 21H ; CALL INTERRUPT
		; DISPLAYING 100TH SECONDS
		MOV AL,BYTE PTR DIFF_WR[1] ; AL = HHHHHHHS
		AND AL,0FEH ; AL = HHHHHHH0
		SHR AL,1 ; AL = 0HHHHHHH
		XOR AH,AH ; AH = 0
		MOV BX, 10; BX = 10
		XOR DX, DX; DX = 0
		DIV BX; DIVIDE TO SEPERATE DIGITS ( DL = RIGHT DIGIT , AL = LEFT DIGIT )
		MOV BL,DL ; BL = DL
		MOV DL,AL ; DL = AL
		ADD DL, '0' ; CONVERT DIGIT TO ASCII
		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		INT 21H; CALL INTERRUPT
		MOV DL,BL ; DL = BL
		ADD DL, '0' ; CONVERT DIGIT TO ASCII
		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		INT 21H ; CALL INTERRUPT

		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		MOV DL,0DH ; DL = CARRIAGE RETURN
		INT 21H; CALL INTERRUPT
		MOV DL,0AH; DL = LINE FEED
		INT 21H; CALL INTERRUPT

		POP DX; RETRIEVE REGISTERS
		POP CX; RETRIEVE REGISTERS
		POP BX; RETRIEVE REGISTERS
		POP AX; RETRIEVE REGISTERS
		RET
	DISPLAY_DIFF_WR ENDP

	ENDALL: ; EXIT

.EXIT
	END
	
; CAS20110225.PDF
; SUMMER OLYMPIC GAMES
; BY WAQAR HASSAN S197729