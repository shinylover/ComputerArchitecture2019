; CAS20120622.PDF
; RUN LENGTH ENCODING
; BY WAQAR HASSAN S197729

N EQU 48 ; NUMBER OF ELEMENTS IN THE ARRAY "IMAGE"

.8086
.MODEL SMALL
.STACK 100H
.DATA

	IMAGE DB 0FH,0FH,0FH,4H,5H,6H,7H,8H,9H,0AH,0AH,0AH,0AH,0AH,0AH,0AH,11H,12H,13H,14H,15H,15H,15H,15H,15H,15H,15H,1CH,1DH,1EH,1FH,20H,20H,20H,20H,20H,25H,26H,27H,28H,29H,2AH,2BH,2CH,2FH,2FH,2FH,30H ; IMAGE ARRAY
	COMPRESSED DB N DUP (?) ; COMPRESSED IMAGE ARRAY
	
	N_COMPRESSED DW ? ; FOR SIZE OF COMPRESSED
	HEX_ARRAY db "0123456789ABCDEF" ; ARRAY FOR EASY PRINTING OF HEXADECIMAL NUMBERS
	
	;STRING MESSAGES
	STRING_IMAGE DB "ORIGINAL IMAGE: (HEX)$"
	STRING_COMP DB "COMPRESSED IMAGE: (HEX)$" ; STRING 
	
.CODE
.STARTUP
	MAIN PROC; STARTING THE MAIN PROCEDURE
		CALL DISPLAYIMAGE ; CALL THE PROCEDURE TO DISPLAY IMAGE ARRAY
		CALL COMPRESS; CALL THE PROCEDURE TO COMPRESS IMAGE ARRAY INTO COMPRESSED ARRAY
		CALL DISPLAYCOMPRESSED; CALL THE PROCEDURE TO DISPLAY COMPRESSED IMAGE ARRAY
		JMP ENDALL; EXIT
	MAIN ENDP   

    COMPRESS PROC ; PROCEDURE FOR COMPRESSING IMAGE ARRAY INTO COMPRESSED ARRAY
		PUSH AX; SAVE REGISTERS
		PUSH BX; SAVE REGISTERS
		PUSH CX; SAVE REGISTERS
		PUSH DX; SAVE REGISTERS
		
		XOR SI,SI; SI = 0 (WILL BE USED TO TRANSVERSE TRHOUGH IMAGE ARRAY)
        XOR DI,DI; DI = 0 (WILL BE USED TO TRANSVERSE TRHOUGH COMPRESSED ARRAY)
        NEXT_ELEMENT_CHECK:
        MOV AL, IMAGE [SI] ; AL = ONE ELEMENT OF IMAGE
        CMP SI,N-1 ; COMPARE SI WITH N-1 (CHECK FOR SPECIAL CASE 1; SEE BOTTOM OF FILE FOR DETAILS)
        JE RULE2 ; JUMP TO RULE 2 (FOR SPEICAL CASE 2)
        MOV AH, IMAGE [SI+1] ; AL = NEXT ELEMENT OF IMAGE
        CMP AL,AH ; COMPARE A SPECIFIC ELEMENT AND THE NEXT ONE
        JE RULE1 ; JUMP TO RULE 1 IF THEY ARE EQUAL

        RULE2: ; IMPLEMENTATION OF RULE 2
            MOV BX,DI ; SAVE DI AS IT POINTS TO POINTER BYTE OF CURRENT SEQUENCE OF NON REPEATED ELEMENTS
            MOV COMPRESSED[DI],7FH ; POINTER BYTE = 7FH (NOTICE THAT 7FH + 1 = 80H)
            RULE2_CONTINUE:
				MOV CX,DI ; SAVE DI AS IT MAY POINT TO LAST FILLED PLACE IN COMPRESSED ARRAY
				MOV DI,BX ; RETRIEVE INDEX OF POINTER BYTE OF CURRENT SEQUENCE OF NON REPEATED ELEMENTS
				ADD COMPRESSED[DI],1 ; INCREMENT POINTER BYTE
				MOV DI,CX ; RETRIEVE INDEX OF LAST FILLED PLACE IN COMPRESSED ARRAY
				INC DI ; INCREMENT COMPRESSED ARRAY INDEX
				MOV COMPRESSED[DI],AL ; SAVE THE ORIGINAL BYTE FROM IMAGE TO COMPRESSED
				INC SI ; INCREMENT IMAGE ARRAY INDEX
				CMP SI,N-1 ; CHECK FOR SPECIAL CASE
				JE SPECIAL_CASE2 ; JUMP IF SI = N-1 
				JA SPECIAL_CASE1 ; JUMP IF SI > N-1
				MOV AL,IMAGE[SI] ; AL = ONE ELEMENT OF IMAGE
				MOV AH,IMAGE[SI+1] ; AL = NEXT ELEMENT OF IMAGE
				CMP AL,AH ; COMPARE A SPECIFIC ELEMENT AND THE NEXT ONE
				JNE RULE2_CONTINUE ; JUMP IF THEY ARE UNEQUAL (RULE 2 CAN BE APPLIED TO NEXT ELEMENTS AS WELL)
            ; AFTER CHECK GOTO RULE 1 BECAUSE ELEMENTS WERE EQUAL
			INC DI ; INCREMENT DI SO IT POINTS TO FIRST EMPTY PLACE IN COMPRESSED ARRAY
            JMP NEXT_ELEMENT_CHECK ; CHECK NEXT ELEMENTS
            
        RULE1: ; IMPLEMENTATION OF RULE 1
            MOV COMPRESSED[DI],00H ; SET POINTER BYTE OF CURRENT SEQUENCE OF REPEATED ELEMENTS AS 00H
            MOV COMPRESSED[DI+1],AL ; SAVE THE ORIGINAL BYTE FROM IMAGE (REPEATED) TO COMPRESSED
            RULE1_CONTINUE:
				ADD COMPRESSED[DI],1 ; INCEREMENT POINTER BYTE
				INC SI  ; INCREMENT IMAGE ARRAY INDEX
				CMP SI,N-1 ; CHECK IF CURRENT ELEMENT IS LAST ELEMENT OF IMAGE ARRAY
				JE COMPRESSION_COMPLETE ; JUMP TO COMPLETE COMPRESSION (BASED ON PREVIOUS CONDITION) (REFER TO POINT NUMBER 3 AT THE END OF FILE)
				MOV AL,IMAGE[SI] ; AL = ONE ELEMENT OF IMAGE
				MOV AH,IMAGE[SI+1] ; AL = NEXT ELEMENT OF IMAGE
				CMP AL,AH ; COMPARE A SPECIFIC ELEMENT AND THE NEXT ONE
				JE RULE1_CONTINUE ; JUMP IF THEY ARE EQUAL (RULE 1 CAN BE APPLIED TO NEXT ELEMENTS AS WELL)
            ; AFTER CHECK GOTO RULE 1 OR 2 BECAUSE ELEMENTS WERE UNEQUAL
			ADD DI,2 ; UPDATE DI SO IT POINTS TO FIRST EMPTY PLACE IN COMPRESSED ARRAY
            INC SI ; INCREMENT SI SO IT POINTS FIRST ELEMENT OF SEQUENCE OF NON REPEATED ELEMENTS FOLLOWING THE CURRENT SEQUENCE OF REPEATED ELEMENTS
            JMP NEXT_ELEMENT_CHECK ; CHECK NEXT ELEMENTS
            
        SPECIAL_CASE1: ; SEE BOTTOM OF FILE FOR DETAILS
			DEC DI ; DECREMENT DI SO AT THE END IT WILL CORRECTLY HOLD THE SIZE OF COMPRESSED ARRAY
			JMP COMPRESSION_COMPLETE ; JUMP TO COMPLETE COMPRESSION
        
        SPECIAL_CASE2: ; SEE BOTTOM OF FILE FOR DETAILS
			MOV COMPRESSED[DI+1],AH ; SAVE THE ORIGINAL LAST BYTE FROM IMAGE TO COMPRESSED      
			PUSH DI ; SAVE DI
			MOV DI,BX ; RETRIEVE INDEX OF POINTER BYTE OF CURRENT SEQUENCE OF NON REPEATED ELEMENTS
			ADD COMPRESSED[DI],1 ; INCREMENT POINTER BYTE
			POP DI ; RETRIEVE DI 

        COMPRESSION_COMPLETE:
			ADD DI,2 ; ADJUST DI SO IT CORRECTLY HOLD THE SIZE OF COMPRESSED ARRAY
			MOV N_COMPRESSED,DI ; SAVE SIZE OF COMPRESSED ARRAY (FOR PRINTING LATER ON)
		
		POP DX; RETRIEVE REGISTERS
		POP CX; RETRIEVE REGISTERS
		POP BX; RETRIEVE REGISTERS
		POP AX; RETRIEVE REGISTERS
        
		RET
    COMPRESS ENDP
    
    DISPLAYIMAGE PROC ; PROCEDURE FOR DISPLAYING IMAGE ARRAY
		PUSH AX; SAVE REGISTERS
		PUSH BX; SAVE REGISTERS
		PUSH CX; SAVE REGISTERS
		PUSH DX; SAVE REGISTERS
        MOV AH,09H ; PREPARE AH FOR STRING OUTPUT
		MOV DX,OFFSET STRING_IMAGE; PREPARE DX WITH OFFSET OF STRING TO DISPLAY
		INT 21H; CALL INTERRUPT
		
		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		MOV DL,0DH ; DL = CARRIAGE RETURN
		INT 21H; CALL INTERRUPT
		MOV DL,0AH; DL = LINE FEED
		INT 21H; CALL INTERRUPT
		
		XOR SI,SI ; SI = 0
		XOR CX,CX ; CX = 0
		IMAGE_NEXT_ELEMENT:
			MOV BL,IMAGE[SI] ; BL TO ONE ELEMENT OF IMAGE ARRAY
			MOV CH,BL ; COPY BL TO CH
			AND CH,0F0H ; AND CH WITH 0F0H TO GET THE HIGHER NIBBLE OF CH
			MOV CL,4 ; PREPARE CL FOR SHIFTING 4 TIMES
			SHR CH,CL ; SHIFT 4 TIMES TO RIGHT
			XOR CL,CL ; CL = 0
			XCHG CH,CL ; SWAP CL AND CH
			MOV DI,CX ; DI = CX (DI = 00000000 0000XXXX)
			MOV DL,HEX_ARRAY[DI] ; DL = ASCI CODE OF THE CHARACTER
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			MOV CL,BL ; COPY BL TO CH
			AND CL,0FH ; AND CH WITH 0FH TO GET THE LOWER NIBBLE OF CH
			MOV DI,CX ; DI = CX (DI = 00000000 0000XXXX)
			MOV DL,HEX_ARRAY[DI] ; DL = ASCI CODE OF THE CHARACTER
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			
			MOV DL," " ; PREPARE DL WITH SPACE KEY
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			
			INC SI ; INCEREMENT SI
			CMP SI,N; COMPARE SI WITH N TO CHECK IF ALL IMAGE ARRAY HAS BEEN DISPLAYED
			JNE IMAGE_NEXT_ELEMENT ; JUMP DEPENDING ON PREVIOUS CONDITION
    	
		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		MOV DL,0DH ; DL = CARRIAGE RETURN
		INT 21H; CALL INTERRUPT
		MOV DL,0AH; DL = LINE FEED
		INT 21H; CALL INTERRUPT
		
		POP DX; RETRIEVE REGISTERS
		POP CX; RETRIEVE REGISTERS
		POP BX; RETRIEVE REGISTERS
		POP AX; RETRIEVE REGISTERS
		RET
        
    DISPLAYIMAGE ENDP

    DISPLAYCOMPRESSED PROC ; PROCEDURE FOR DISPLAYING COMPRESSED ARRAY
		PUSH AX; SAVE REGISTERS
		PUSH BX; SAVE REGISTERS
		PUSH CX; SAVE REGISTERS
		PUSH DX; SAVE REGISTERS
		
        MOV AH,09H ; PREPARE AH FOR STRING OUTPUT
		MOV DX,OFFSET STRING_COMP; PREPARE DX WITH OFFSET OF STRING TO DISPLAY
		INT 21H; CALL INTERRUPT
		
		MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
		MOV DL,0DH ; DL = CARRIAGE RETURN
		INT 21H; CALL INTERRUPT
		MOV DL,0AH; DL = LINE FEED
		INT 21H; CALL INTERRUPT
		
		XOR SI,SI ; SI = 0
		XOR CX,CX ; CX = 0
		COMPRESSED_NEXT_ELEMENT:
			MOV BL,COMPRESSED[SI] ; BL TO ONE ELEMENT OF COMPRESSED ARRAY
			MOV CH,BL ; COPY BL TO CH
			AND CH,0F0H ; AND CH WITH 0F0H TO GET THE HIGHER NIBBLE OF CH
			MOV CL,4 ; PREPARE CL FOR SHIFTING 4 TIMES
			SHR CH,CL ; SHIFT 4 TIMES TO RIGHT
			XOR CL,CL ; CL = 0
			XCHG CH,CL ; SWAP CL AND CH
			MOV DI,CX ; DI = CX (DI = 00000000 0000XXXX)
			MOV DL,HEX_ARRAY[DI] ; DL = ASCII CODE OF THE CHARACTER
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			MOV CL,BL ; COPY BL TO CH
			AND CL,0FH ; AND CH WITH 0FH TO GET THE LOWER NIBBLE OF CH
			MOV DI,CX ; DI = CX (DI = 00000000 0000XXXX)
			MOV DL,HEX_ARRAY[DI] ; DL = ASCII CODE OF THE CHARACTER
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			
			MOV DL," " ; PREPARE DL WITH SPACE KEY
			MOV AH,02H; PREPARE AH FOR CHARACTER OUTPUT
			INT 21H ; CALL INTERRUPT
			
			INC SI ; INCEREMENT SI
			CMP SI,N_COMPRESSED ; COMPARE SI WITH N_COMPRESSED TO CHECK IF ALL COMPRESSED ARRAY HAS BEEN DISPLAYED
			JNE COMPRESSED_NEXT_ELEMENT ; JUMP DEPENDING ON PREVIOUS CONDITION
		
		POP DX; RETRIEVE REGISTERS
		POP CX; RETRIEVE REGISTERS
		POP BX; RETRIEVE REGISTERS
		POP AX; RETRIEVE REGISTERS
		RET
        
    DISPLAYCOMPRESSED ENDP
	
	ENDALL: ; EXIT

.EXIT
	END
	
; POINTER BYTE REFERS TO THE BYTE IN QUOTES ( "81" 02 43 OR "01" 05 )

; IMAGE ARRAY MAY END IN A NUMBER OF WAYS
;	1) . . . X X X Y
;		IN THIS CASE WE NEED TO APPLY RULE 2 FOR THE LAST BYTE (Y IN THE EXAMPLE) (REFERED TO AS SPECIAL CASE 1)
;	2) . . . X X Y Z
;		IN THIS CASE WE NEED TO APPLY RULE 2 FOR LAST BYTES (Y AND Z IN THE EXAMPLE) (REFERED TO AS SPECIAL CASE 2)
; 	3) . . . X X X X
;		IN THIS CASE WE NEEED TO APPLY RULE 1 FOR LAST BYTES (X IN THE EXAMPLE)

; CAS20120622.PDF
; RUN LENGTH ENCODING
; BY WAQAR HASSAN S197729